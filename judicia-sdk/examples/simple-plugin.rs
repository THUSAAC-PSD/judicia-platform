//! Simple example plugin demonstrating basic Judicia SDK usage

use judicia_sdk::prelude::*;

/// A simple plugin that reacts to submission events
#[judicia_plugin]
pub struct SimplePlugin {
    name: "simple-plugin",
    version: "1.0.0", 
    author: "Judicia Team",
    description: "A simple example plugin that demonstrates basic functionality",
    capabilities: [
        Capability::SubscribeEvents,
        Capability::EmitEvent,
        Capability::SendNotifications
    ]
}

impl PluginMethods for SimplePlugin {
    async fn on_initialize(&mut self, context: &PluginContext) -> PluginResult<()> {
        info!("Simple Plugin initialized with ID: {}", context.plugin_id);
        
        // Set up event subscriptions
        let subscription = EventSubscription::new(context.plugin_id)
            .subscribe_to_all_submissions()
            .subscribe_to("contest.started");
            
        subscription.register().await?;
        
        Ok(())
    }

    async fn on_event(&mut self, event: &PlatformEvent) -> PluginResult<()> {
        match event.event_type.as_str() {
            "submission.created" => {
                info!("New submission received: {}", event.id);
                
                // Extract submission data
                if let Some(submission_id) = event.payload.get("submission_id") {
                    // Send a welcome notification to the user
                    if let Some(user_id_value) = event.payload.get("user_id") {
                        if let Some(user_id_str) = user_id_value.as_str() {
                            if let Ok(user_id) = Uuid::parse_str(user_id_str) {
                                let notification = NotificationBuilder::new(user_id)
                                    .title("Submission Received")
                                    .message("Your submission has been received and will be evaluated shortly.")
                                    .notification_type(NotificationType::Info)
                                    .urgency(NotificationUrgency::Normal)
                                    .build();
                                
                                // This would require platform integration to actually send
                                info!("Would send notification to user: {}", user_id);
                            }
                        }
                    }
                }
            }
            
            "contest.started" => {
                info!("Contest started: {}", event.payload);
                
                // Emit a custom event
                let custom_event_payload = serde_json::json!({
                    "plugin_name": "simple-plugin",
                    "message": "Contest monitoring activated",
                    "contest_data": event.payload
                });
                
                // Would emit to platform event bus
                info!("Would emit custom event with payload: {}", custom_event_payload);
            }
            
            _ => {
                debug!("Received unhandled event: {}", event.event_type);
            }
        }
        
        Ok(())
    }

    async fn on_cleanup(&mut self) -> PluginResult<()> {
        info!("Simple Plugin cleaning up");
        Ok(())
    }
}

// In a real WebAssembly plugin, this would be automatically generated by the macro
// and would export the plugin to the WebAssembly host
#[cfg(target_arch = "wasm32")]
mod wasm_exports {
    use super::*;
    use wasm_bindgen::prelude::*;
    
    static mut PLUGIN: Option<SimplePlugin> = None;
    
    #[wasm_bindgen(start)]
    pub fn main() {
        console_error_panic_hook::set_once();
        unsafe {
            PLUGIN = Some(SimplePlugin {});
        }
    }
    
    #[wasm_bindgen]
    pub async fn plugin_initialize(context: JsValue) -> Result<(), JsValue> {
        let context: PluginContext = context.into_serde()
            .map_err(|e| JsValue::from_str(&e.to_string()))?;
        
        unsafe {
            if let Some(ref mut plugin) = &mut PLUGIN {
                plugin.on_initialize(&context).await
                    .map_err(|e| JsValue::from_str(&e.to_string()))?;
            }
        }
        
        Ok(())
    }
    
    #[wasm_bindgen]
    pub async fn plugin_handle_event(event: JsValue) -> Result<(), JsValue> {
        let event: PlatformEvent = event.into_serde()
            .map_err(|e| JsValue::from_str(&e.to_string()))?;
        
        unsafe {
            if let Some(ref mut plugin) = &mut PLUGIN {
                plugin.on_event(&event).await
                    .map_err(|e| JsValue::from_str(&e.to_string()))?;
            }
        }
        
        Ok(())
    }
}